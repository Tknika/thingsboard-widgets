{
  "fqn": "tk_devicetable_v0_5",
  "name": "TK_Device_Telemetries_Maintenance_v1.0",
  "deprecated": false,
  "image": "tb-image:dXNhZ2VfaW5mb19zeXN0ZW1fd2lkZ2V0X2ltYWdlLnBuZw==:IlVzYWdlIGluZm8iIHN5c3RlbSB3aWRnZXQgaW1hZ2U=:SU1BR0U=;data:image/png;base64,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",
  "description": "Display statistics about the number of entities and API usage.",
  "descriptor": {
    "type": "static",
    "sizeX": 17,
    "sizeY": 10.5,
    "resources": [],
    "templateHtml": "<div class=\"tb-widget\" style=\"padding: 10px; display: flex; flex-direction: column;\">\r\n    <!-- Contenedor para el encabezado con Device Filter y Include customer entities -->\r\n    <div style=\"display: flex; justify-content: space-between; align-items: center; padding-bottom: 10px;\">\r\n        <h4 style=\"margin: 0;\">Device telemetries maintenance</h4>\r\n        <div style=\"display: flex; align-items: center;\">\r\n            <!-- Botón Device Filter -->\r\n            <button mat-raised-button style=\"margin-right: 20px; display: flex; align-items: center;\" (click)=\"toggleFilterDialog()\">\r\n                <i class=\"material-icons\" style=\"font-size: 18px; margin-right: 5px;\">filter_list</i> Device Filter\r\n            </button>\r\n            <!-- Toggle Include customer entities -->\r\n            <div style=\"display: flex; align-items: center; margin-right: 20px;\">\r\n                <label for=\"includeCustomerEntitiesToggle\" style=\"margin-right: 10px;\">Include customer entities</label>\r\n                <label class=\"switch\">\r\n                    <input type=\"checkbox\" id=\"includeCustomerEntitiesToggle\" [(ngModel)]=\"includeCustomerEntities\" (ngModelChange)=\"applyFilter()\">\r\n                    <span class=\"slider round\"></span>\r\n                </label>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Contenedor para la tabla con altura dinámica ajustada -->\r\n    <div class=\"table-container\" style=\"overflow-y: auto; overflow-x: auto;\">\r\n        <table class=\"tb-alarms-table tb-data-table\" [ctx]=\"ctx\" style=\"width: 100%; table-layout: fixed; border-collapse: collapse;\">\r\n            <thead class=\"sticky-header\" style=\"background-color: white; border-bottom: 2px solid #ddd;\">\r\n                <tr>\r\n                    <th style=\"width: 5%; text-align: left; padding: 10px;\">\r\n                        <input type=\"checkbox\" [(ngModel)]=\"selectAll\" (click)=\"toggleSelectAll()\" />\r\n                    </th>\r\n                    <th style=\"width: 15%; text-align: left; padding: 10px; font-weight: bold;\">\r\n                        Created time <span style=\"font-size: 12px;\">&#x25BC;</span>\r\n                    </th>\r\n                    <th style=\"width: 15%; text-align: left; padding: 10px; font-weight: bold;\">Name</th>\r\n                    <th style=\"width: 15%; text-align: left; padding: 10px; font-weight: bold;\">Device profile</th>\r\n                    <th style=\"width: 15%; text-align: left; padding: 10px; font-weight: bold;\">Label</th>\r\n                    <th style=\"width: 10%; text-align: left; padding: 10px; font-weight: bold;\">State</th>\r\n                    <th style=\"width: 15%; text-align: left; padding: 10px; font-weight: bold;\">Owner name</th>\r\n                    <th style=\"width: 15%; text-align: left; padding: 10px; font-weight: bold;\">Description</th>\r\n                    <th style=\"width: 10%; text-align: center; padding: 10px; font-weight: bold;\">Actions</th>\r\n                </tr>\r\n            </thead>\r\n            <tbody>\r\n                <tr *ngFor=\"let entity of filteredEntities; let i = index\" \r\n                    (click)=\"onRowClick(entity)\" \r\n                    class=\"tb-data-row\" \r\n                    [style.background-color]=\"i % 2 === 0 ? '#f9f9f9' : '#ffffff'\" \r\n                    style=\"border-bottom: 1px solid #ddd; height: 50px;\">\r\n                    <td style=\"text-align: left; padding: 10px;\">\r\n                        <input type=\"checkbox\" [(ngModel)]=\"entity.selected\" (change)=\"onCheckboxChange(entity)\" />\r\n                    </td>\r\n                    <td style=\"text-align: left; padding: 10px;\">{{entity.createdTime | date:'yyyy-MM-dd HH:mm:ss'}}</td>\r\n                    <td style=\"text-align: left; padding: 10px;\">{{entity.name}}</td>\r\n                    <td style=\"text-align: left; padding: 10px;\">{{entity.type}}</td>\r\n                    <td style=\"text-align: left; padding: 10px;\">{{entity.label}}</td>\r\n                    <td style=\"text-align: left; padding: 10px;\">\r\n                        <span *ngIf=\"entity.active === 'Active'\" style=\"background-color: #e8f5e9; color: #4caf50; padding: 4px 8px; border-radius: 12px;\">Active</span>\r\n                        <span *ngIf=\"entity.active === 'Inactive'\" style=\"background-color: #ffebee; color: #f44336; padding: 4px 8px; border-radius: 12px;\">Inactive</span>\r\n                    </td>\r\n                    <td style=\"text-align: left; padding: 10px;\">{{entity.ownerName}}</td>\r\n                    <td style=\"text-align: left; padding: 10px;\">{{entity.description}}</td>\r\n                    <td style=\"text-align: center; padding: 10px;\">\r\n                        <!-- Ícono de descarga (download) -->\r\n                        <span style=\"cursor: pointer;\" (click)=\"onDownloadAction(entity)\">\r\n                            <i class=\"material-icons\">download</i>\r\n                        </span> &nbsp;\r\n                        <!-- Ícono de eliminar (delete) -->\r\n                        <span style=\"cursor: pointer;\" (click)=\"onDeleteAction(entity)\">\r\n                            <i class=\"material-icons\">delete</i>\r\n                        </span>\r\n                    </td>\r\n                </tr>\r\n            </tbody>\r\n        </table>\r\n    </div>\r\n\r\n    \r\n    <!-- Ventana flotante de Device Filter -->\r\n    <div *ngIf=\"showFilterDialog\" class=\"filter-dialog\" style=\"position: absolute; top: 80px; right: 50px; background-color: white; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); padding: 20px; z-index: 1000; border-radius: 8px;\">\r\n        <div style=\"display: flex; justify-content: space-between; margin-bottom: 10px;\">\r\n            <span style=\"font-weight: bold;\">Device type</span>\r\n            <span style=\"cursor: pointer;\" (click)=\"closeFilterDialog()\">&#x2716;</span>\r\n        </div>\r\n        <select [(ngModel)]=\"selectedDeviceType\" style=\"width: 100%; padding: 8px; margin-bottom: 20px;\">\r\n            <option value=\"All\">All</option>\r\n            <!-- Generar dinámicamente las opciones a partir de deviceTypes -->\r\n            <option *ngFor=\"let type of deviceTypes\" [value]=\"type\">{{type}}</option>\r\n        </select>\r\n        <div style=\"font-weight: bold;\">Device state</div>\r\n        <select [(ngModel)]=\"selectedDeviceState\" style=\"width: 100%; padding: 8px;\">\r\n            <option value=\"Any\">Any</option>\r\n            <option value=\"Active\">Active</option>\r\n            <option value=\"Inactive\">Inactive</option>\r\n        </select>\r\n        <div style=\"display: flex; justify-content: space-between; margin-top: 20px;\">\r\n            <button mat-button (click)=\"closeFilterDialog()\">Cancel</button>\r\n            <button mat-button color=\"primary\" (click)=\"applyFilter()\">Update</button>\r\n        </div>\r\n    </div>\r\n\r\n    <!-- Footer con posición fija y tamaño fijo -->\r\n    <div class=\"footer\" style=\"position: fixed; bottom: 0; left: 0; right: 0; background-color: white; padding: 10px; box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1); z-index: 1000; display: flex; justify-content: space-between;\">\r\n        <div style=\"margin-left: 10px;\">\r\n            Selected devices: {{ selectedCounter }} / {{ filteredEntitiesCounter }}\r\n        </div>\r\n        <div style=\"margin-right: 10px;\">\r\n            <button mat-raised-button color=\"primary\" (click)=\"showDownloadDialog()\">Download selected telemetries</button> &nbsp;\r\n            <button mat-raised-button color=\"primary\" (click)=\"showDownloadAndDeleteDialog()\">Download and delete selected telemetries</button>\r\n        </div>\r\n    </div>\r\n    \r\n    <!-- Overlay de carga que cubre todo el widget -->\r\n    <div *ngIf=\"loading\" class=\"loading-overlay\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.8); display: flex; align-items: center; justify-content: center; z-index: 1000;\">\r\n        <div class=\"loading-spinner\">\r\n            <span>Working in progress... please wait!</span>\r\n        </div>\r\n    </div>\r\n</div>\r\n",
    "templateCss": ".table-container {\r\n    position: relative;\r\n}\r\n\r\n.sticky-header th {\r\n    position: sticky;\r\n    top: 0;\r\n    z-index: 1;\r\n    background-color: #ffffff; /* Fondo blanco o del color que prefieras */\r\n}\r\n\r\n\r\n.switch {\r\n  position: relative;\r\n  display: inline-block;\r\n  width: 34px;\r\n  height: 20px;\r\n}\r\n\r\n.switch input { \r\n  opacity: 0;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\n.slider {\r\n  position: absolute;\r\n  cursor: pointer;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  background-color: #ccc;\r\n  transition: .4s;\r\n  border-radius: 20px;\r\n}\r\n\r\n.slider:before {\r\n  position: absolute;\r\n  content: \"\";\r\n  height: 14px;\r\n  width: 14px;\r\n  left: 3px;\r\n  bottom: 3px;\r\n  background-color: white;\r\n  transition: .4s;\r\n  border-radius: 50%;\r\n}\r\n\r\ninput:checked + .slider {\r\n  background-color: #4caf50;\r\n}\r\n\r\ninput:checked + .slider:before {\r\n  transform: translateX(14px);\r\n}\r\n\r\n.loading-overlay .loading-spinner {\r\n    font-size: 18px;\r\n    color: #333;\r\n    animation: fadeIn 1s infinite alternate;\r\n}\r\n\r\n@keyframes fadeIn {\r\n    from { opacity: 0.5; }\r\n    to { opacity: 1; }\r\n}\r\n",
    "controllerScript": "\r\nself.onInit = async function() {\r\n    let $injector = self.ctx.$scope.$injector;\r\n    let entityService = $injector.get(self.ctx.servicesMap.get('entityService'));\r\n    let attributeService = $injector.get(self.ctx.servicesMap.get('attributeService'));\r\n    \r\n    self.ctx.$scope.loading = false;  // Inicialmente no está cargando\r\n    \r\n    self.ctx.$scope.selectedCounter = 0;\r\n    self.ctx.$scope.filteredEntitiesCounter = 0;\r\n    self.ctx.$scope.includeCustomerEntities = true;\r\n    self.ctx.$scope.entities = [];\r\n    self.ctx.$scope.filteredEntities = [];\r\n    self.ctx.$scope.deviceTypes = [];\r\n    self.ctx.$scope.selectAll = false; // Estado del checkbox \"Seleccionar todos\"\r\n    self.ctx.$scope.selectedDeviceType = 'All';\r\n    self.ctx.$scope.selectedDeviceState = 'Any';\r\n    \r\n    // Controla la visibilidad del cuadro de diálogo de filtro\r\n    self.ctx.$scope.showFilterDialog = false;\r\n    \r\n    self.ctx.$scope.toggleFilterDialog = function() {\r\n      // Alterna el estado de visibilidad del cuadro de diálogo\r\n      self.ctx.$scope.showFilterDialog = !self.ctx.$scope.showFilterDialog;\r\n    }\r\n    \r\n    self.ctx.$scope.closeFilterDialog = function() {\r\n      // Cierra el cuadro de diálogo de filtro\r\n      self.ctx.$scope.showFilterDialog = false;\r\n    }\r\n    \r\n    self.ctx.$scope.applyFilter = function() {\r\n      // Captura los valores seleccionados de los filtros\r\n      const selectedDeviceType = self.ctx.$scope.selectedDeviceType;\r\n      const selectedState = self.ctx.$scope.selectedDeviceState;\r\n      const includeCustomerEntities = self.ctx.$scope.includeCustomerEntities;\r\n    \r\n      console.log('Filtro aplicado:', {\r\n        selectedDeviceType: selectedDeviceType,\r\n        selectedDeviceState: selectedState,\r\n        includeCustomerEntities: includeCustomerEntities\r\n      });\r\n    \r\n      // Filtrar las entidades en función del perfil, estado, y si se incluyen entidades de clientes\r\n      self.ctx.$scope.filteredEntities = self.ctx.$scope.entities.filter(function(entity) {\r\n        // Verificar si el perfil seleccionado es 'All' o si coincide con el perfil de la entidad\r\n        const profileMatches = selectedDeviceType === 'All' || entity.type === selectedDeviceType;\r\n    \r\n        // Verificar si el estado seleccionado es 'Any' o si coincide con el estado de la entidad\r\n        const stateMatches = selectedState === 'Any' || entity.active == selectedState;\r\n    \r\n        // Verificar si incluir o excluir entidades de clientes\r\n        const includeCustomer = includeCustomerEntities || entity.ownerId.id === entity.tenantId.id;\r\n    \r\n        // Retornar solo las entidades que coinciden con los tres filtros\r\n        return profileMatches && stateMatches && includeCustomer;\r\n      });\r\n    \r\n      // Actualiza la tabla con las entidades filtradas\r\n      self.ctx.$scope.filteredEntitiesCounter = self.ctx.$scope.filteredEntities.length;\r\n    \r\n      // Cierra el cuadro de diálogo de filtro si está abierto\r\n      self.ctx.$scope.closeFilterDialog();\r\n      \r\n      self.ctx.detectChanges();\r\n    };\r\n\r\n    \r\n    self.ctx.$scope.toggleSelectAll = function() {\r\n        self.ctx.$scope.selectAll = !self.ctx.$scope.selectAll;\r\n        self.ctx.$scope.filteredEntities.forEach(function(entity) {\r\n            entity.selected = self.ctx.$scope.selectAll;\r\n            if(entity.selected){\r\n                self.ctx.$scope.selectedCounter++;\r\n            }else{\r\n                self.ctx.$scope.selectedCounter--;\r\n            }\r\n        });\r\n        self.ctx.detectChanges();\r\n\r\n    };\r\n    \r\n    // Función que se ejecuta al hacer clic en una fila de la tabla\r\n    self.ctx.$scope.onRowClick = function(entity) {\r\n        console.log('Linea seleccionada:', entity);\r\n        /*if(entity.selected){\r\n            self.ctx.$scope.selectedCounter++;\r\n        }else{\r\n            self.ctx.$scope.selectedCounter--;\r\n        }\r\n        self.ctx.detectChanges();*/\r\n    };\r\n    \r\n    self.ctx.$scope.onCheckboxChange = function(entity) {\r\n        console.log('Entidad seleccionada:', entity);\r\n\r\n        // Actualiza el contador de seleccionados, si es necesario\r\n        self.ctx.$scope.selectedCounter = self.ctx.$scope.entities.filter(e => e.selected).length;\r\n        self.ctx.detectChanges();\r\n    }\r\n    \r\n    // Ejemplo de función para el ícono de \"download\"\r\n    self.ctx.$scope.onDownloadAction = function(entity) {\r\n        // Lógica para descargar información relacionada con el dispositivo\r\n        //console.log('Download action triggered for:', entity);\r\n        let title = \"Are you sure you want to download all telemetries for this device?\";\r\n        let content = \"After the confirmation, the device related data will download!\";\r\n        self.ctx.dialogs.confirm(title, content, 'I\\'m not sure', 'Yes, sure!').subscribe(\r\n            function(result) {\r\n                if (result) {\r\n                    self.exportDeviceTelemetries(entity.id, entity.name, false);\r\n                }\r\n            }\r\n        );\r\n    }\r\n    \r\n    self.ctx.$scope.onDeleteAction = function(entity) {\r\n        // Confirmación antes de eliminar\r\n        let title = \"Are you sure you want to delete all telemetries?\";\r\n        let content = \"Be careful, after the confirmation, device all related data will become unrecoverable!\";\r\n        self.ctx.dialogs.confirm(title, content, 'I\\'m not sure', 'Yes, sure!').subscribe(\r\n            function(result) {\r\n                if (result) {\r\n                    let $injector = self.ctx.$scope\r\n                            .$injector;\r\n                    let attributeService = $injector.get(\r\n                            self.ctx.servicesMap.get(\r\n                                'attributeService'));\r\n                    attributeService.getEntityTimeseriesLatest(\r\n                            entity).subscribe((\r\n                            labels) => {\r\n                        var datakey = Object.keys(labels);\r\n                        self.deleteTimeseriesValues(entity, datakey, deleteAllDataForKeys);\r\n                    });\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    self.ctx.$scope.showDownloadDialog = function() {\r\n        //console.log('showDownloadDialog()');\r\n        \r\n        /*var title = 'alert';\r\n        var body = 'alert';\r\n        var ok_message = 'alert';\r\n        self.ctx.dialogs.alert(title, body, ok_message).subscribe()*/\r\n        \r\n        let title = \"Are you sure you want to download all telemetries?\";\r\n        let content = \"After the confirmation, the device related data will download!\";\r\n        self.ctx.dialogs.confirm(title, content, 'I\\'m not sure', 'Yes, sure!').subscribe(\r\n            function(result) {\r\n                if (result) {\r\n                    self.ctx.$scope.entities.forEach(function(entity) {\r\n                        if(entity.selected){\r\n                            console.log(entity);\r\n                            self.exportDeviceTelemetries(entity.id, entity.name, false);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        );\r\n    };\r\n\r\n    self.ctx.$scope.showDownloadAndDeleteDialog = function() {\r\n        //console.log('showDownloadDialog()');\r\n        \r\n        /*var title = 'alert';\r\n        var body = 'alert';\r\n        var ok_message = 'alert';\r\n        self.ctx.dialogs.alert(title, body, ok_message).subscribe()*/\r\n        \r\n        let title = \"Are you sure you want to download and delete all telemetries?\";\r\n        let content = \"Be careful, after the confirmation, device all related data will become unrecoverable!\";\r\n        self.ctx.dialogs.confirm(title, content, 'I\\'m not sure', 'Yes, sure!').subscribe(\r\n            function(result) {\r\n                if (result) {\r\n                    self.ctx.$scope.entities.forEach(function(entity) {\r\n                        if(entity.selected){\r\n                            console.log(entity);\r\n                            self.exportDeviceTelemetries(entity.id, entity.name, true);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        );\r\n    };\r\n    \r\n    \r\n    \r\n\r\n    \r\n    const response = await self.getDeviceInfos();\r\n    self.ctx.$scope.entities = self.extractDeviceInfo(response);\r\n    self.ctx.$scope.filteredEntities = self.ctx.$scope.entities || [];\r\n    self.ctx.$scope.deviceTypes = [...new Set(self.ctx.$scope.entities.map(entity => entity.type))];\r\n    self.ctx.$scope.filteredEntitiesCounter = self.ctx.$scope.filteredEntities.length;\r\n    //self.ctx.$scope.entities = entities;\r\n    self.ctx.detectChanges();\r\n    self.adjustTableHeight();\r\n    //console.log(self.ctx.$scope.entities);\r\n\r\n    // Definir la consulta para obtener los dispositivos\r\n    /*let entityFilter = {\r\n        type: 'entityType',\r\n        entityType: 'DEVICE'\r\n    };\r\n\r\n    let query = {\r\n        entityFilter: entityFilter,\r\n        pageLink: {\r\n            page: 0,\r\n            pageSize: 100\r\n        }\r\n    };\r\n\r\n    // Usar findEntityDataByQuery para obtener dispositivos\r\n    entityService.findEntityDataByQuery(query).subscribe(\r\n        function(entities) {\r\n            //debugger;\r\n            self.devices = entities.data;\r\n            self.loadTelemetryData();\r\n        },\r\n        function(error) {\r\n            console.error('Error al cargar las entidades:', error);\r\n        }\r\n    );*/\r\n};\r\n\r\nself.onResize = function() {\r\n    self.adjustTableHeight();\r\n};\r\n\r\nself.adjustTableHeight = function() {\r\n    // Obtener las alturas de los elementos fijos\r\n    const headerHeight = document.querySelector('.tb-widget h4').clientHeight;\r\n    const footerHeight = document.querySelector('.footer').clientHeight;\r\n    const widgetHeight = self.ctx.$container.height();\r\n\r\n    // Calcular la altura disponible para la tabla\r\n    const availableHeight = widgetHeight - headerHeight - footerHeight - 30;\r\n\r\n    // Ajustar la altura del contenedor de la tabla\r\n    const tableContainer = document.querySelector('.table-container');\r\n    if (tableContainer) {\r\n        tableContainer.style.height = `${availableHeight}px`;\r\n    }\r\n}\r\n\r\n\r\nself.getDeviceInfos = async function() {\r\n    try {\r\n        // Usar await para esperar a la respuesta de la solicitud HTTP\r\n        //http://172.17.17.1:8080/api/deviceInfos/all?pageSize=30&page=0&sortProperty=createdTime&sortOrder=DESC&includeCustomers=true\r\n        const response = await self.ctx.http.get(\r\n            '/api/deviceInfos/all?pageSize=1000&page=0&sortProperty=createdTime&sortOrder=DESC&includeCustomers=true'\r\n            ).toPromise();\r\n        return response;  // Devolver la respuesta para su uso posterior\r\n    } catch (error) {\r\n        console.error('Error al hacer la solicitud HTTP:', error);\r\n        return null;  // Manejar el error devolviendo un valor nulo o realizando otras acciones\r\n    }\r\n};\r\n\r\nself.extractDeviceInfo = function(dataObject) {\r\n    // Obtenemos el array 'data' del objeto\r\n    const { data } = dataObject;\r\n//debugger;\r\n    // Mapeamos el array 'data' para extraer los datos requeridos\r\n    return data.map(device => {\r\n        return {\r\n            name: device.name,\r\n            type: device.type,\r\n            label: device.label,\r\n            id: device.id.id,\r\n            active: device.active?'Active':'Inactive',\r\n            ownerId: device.ownerId,\r\n            tenantId: device.tenantId,\r\n            ownerName: device.ownerName,\r\n            description: device.additionalInfo?device.additionalInfo.description:'',\r\n            createdTime: device.createdTime,\r\n            selected: false\r\n        };\r\n    });\r\n}\r\n\r\n\r\n\r\n\r\nself.exportDeviceTelemetries = async function(entityId, entityName, deleteTelemetries) {\r\n    try {\r\n        // Mostrar overlay\r\n        self.ctx.$scope.loading = true;\r\n        self.ctx.detectChanges();\r\n\r\n        let $injector = self.ctx.$scope.$injector;\r\n        let attributeService = $injector.get(self.ctx.servicesMap.get('attributeService'));\r\n        const entityType = \"DEVICE\";\r\n        let entity = { id: entityId, entityType: entityType };\r\n        \r\n        const startTs = 0;\r\n        const endTs = Date.now();\r\n        const limit = 10000;\r\n        var entries = {};\r\n\r\n        await attributeService.getEntityTimeseriesLatest(entity).toPromise().then((labels) => {\r\n            var datakey = Object.keys(labels);\r\n            if(datakey.length > 0){\r\n                return self.getTimeseriesValues(entity, datakey, startTs, endTs, limit, entries);\r\n            }else{\r\n                return new Promise((resolve, reject) => {\r\n                    setTimeout(() => {\r\n                        var title = 'Export device telemetries';\r\n                        var body = \"Device '\" + entityName + \"' has no telemetries!\";\r\n                        var ok_message = 'Close';\r\n                        self.ctx.dialogs.alert(title, body, ok_message).subscribe();\r\n                        self.ctx.detectChanges();\r\n                    }, 100);\r\n                    reject();  \r\n                });\r\n            }\r\n            //return self.getTimeseriesValues(entity, datakey, startTs, endTs, limit, entries);\r\n        }).then((result) => {\r\n            const csvContent = self.objectToCsv(entries);\r\n            self.downloadCsv(csvContent, entityName);\r\n            \r\n            if (deleteTelemetries) {\r\n                self.deleteTimeseriesValues(entity, Object.keys(entries), true);\r\n            }\r\n        });\r\n\r\n    } catch (error) {\r\n        //console.error('Error en exportDeviceTelemetries:', error);\r\n    } finally {\r\n        // Ocultar overlay al finalizar\r\n        self.ctx.$scope.loading = false;\r\n        self.ctx.detectChanges();\r\n    }\r\n}\r\n\r\n\r\n\r\nself.exportDeviceTelemetries___OLD = function(entityId, entityName, deleteTelemetries) {\r\n    let $injector = self.ctx.$scope\r\n            .$injector;\r\n    let attributeService = $injector.get(\r\n            self.ctx.servicesMap.get(\r\n                'attributeService'));\r\n    //const entityId = \"9a605190-861a-11ef-88ad-57c6228ae088\";  // Reemplaza con el ID real de la entidad\r\n    const entityType = \"DEVICE\";\r\n    let entity = {\r\n        id: entityId,\r\n        entityType: entityType\r\n    };\r\n    \r\n    const startTs = 0;//Date.now() - (10 * 24 * 60 * 60 * 1000);\r\n    const endTs = Date.now();  // Ahora\r\n    const limit = 10000;  // Límite de datos\r\n    \r\n    var entries = {};\r\n    \r\n    attributeService.getEntityTimeseriesLatest(\r\n            entity).subscribe((\r\n            labels) => {\r\n        var datakey = Object.keys(labels);\r\n        self.getTimeseriesValues(entity, datakey, startTs, endTs, limit, entries)\r\n            .then((result) => {\r\n                //debugger;\r\n                //console.log('Datos completos:', result);\r\n                console.log('Datos completos!');\r\n                // Llamada para generar y descargar el CSV\r\n                const csvContent = self.objectToCsv(entries);  // 'entries' es tu objeto con las dataKeys y arrays\r\n                self.downloadCsv(csvContent, entityName);\r\n                if(deleteTelemetries){\r\n                    console.log('Borrando datos!');\r\n                    let $injector = self.ctx.$scope\r\n                            .$injector;\r\n                    let attributeService = $injector.get(\r\n                            self.ctx.servicesMap.get(\r\n                                'attributeService'));\r\n                    attributeService.getEntityTimeseriesLatest(\r\n                            entity).subscribe((\r\n                            labels) => {\r\n                        var datakey = Object.keys(labels);\r\n                        self.deleteTimeseriesValues(entity, datakey, deleteAllDataForKeys);\r\n                    });\r\n                    \r\n                }\r\n            })\r\n            .catch((error) => {\r\n                //debugger;\r\n                console.error('Error al obtener los datos:', error);\r\n            });\r\n        //console.log('response', values);\r\n    });\r\n}\r\n\r\nself.deleteTimeseriesValues = function(entity, datakey, deleteAllDataForKeys){\r\n    let $injector = self.ctx.$scope.$injector;\r\n    let attributeService = $injector.get(self.ctx.servicesMap.get('attributeService'));\r\n\r\n    console.log(\"Iniciando llamada a deleteTimeseriesValues...\");\r\n\r\n    attributeService.deleteEntityTimeseries(entity, datakey, true)\r\n        .subscribe(() => {\r\n            // Éxito al eliminar los datos de telemetría\r\n            console.log(\"Datos de telemetría eliminados con éxito\");\r\n        }, (error) => {\r\n            // Manejo de errores\r\n            console.error(\"Error al eliminar los datos de telemetría:\", error);\r\n        });\r\n}\r\n\r\n\r\nself.getTimeseriesValues = function(entity, datakey, startTs, endTs, limit, entries) {\r\n    return new Promise((resolve, reject) => {\r\n        let $injector = self.ctx.$scope.$injector;\r\n        let attributeService = $injector.get(self.ctx.servicesMap.get('attributeService'));\r\n\r\n        console.log(\"Iniciando llamada a getEntityTimeseries...\");\r\n        try {\r\n\r\n            attributeService.getEntityTimeseries(entity, datakey, startTs, endTs, limit).subscribe(\r\n                (timeseries) => {\r\n                    debugger;\r\n                    try {\r\n                        //console.log(\"Datos obtenidos de getEntityTimeseries:\", timeseries);\r\n    \r\n                        // Procesar cada key en datakey\r\n                        for (let i = 0; i < datakey.length; i++) {\r\n                            let key = datakey[i];\r\n                            if (entries[key] === undefined) {\r\n                                entries[key] = [];\r\n                            }\r\n                            entries[key] = [...entries[key], ...timeseries[key]];  // Concatenar resultados\r\n                        }\r\n    \r\n                        //console.log(\"Entries actualizados:\", entries);\r\n    \r\n                        // Verificar si se necesita más paginación\r\n                        if (timeseries[datakey[0]] && timeseries[datakey[0]].length === limit) {\r\n                            // Si hay más datos (la longitud del array es igual al límite), seguimos con la recursión\r\n                            let newEndTs = timeseries[datakey[0]][limit - 1].ts;\r\n                            console.log(\"Más datos disponibles, llamando recursivamente con newEndTs:\", newEndTs);\r\n    \r\n                            // Hacer la llamada recursiva, pero asegurarnos de encadenar las promesas\r\n                            self.getTimeseriesValues(entity, datakey, startTs, newEndTs, limit, entries)\r\n                                .then(resolve)  // Resolver la promesa después de la recursividad\r\n                                .catch(reject);  // Rechazar en caso de error\r\n                        } else {\r\n                            // No hay más datos, resolver la promesa con los resultados\r\n                            console.log(\"No hay más datos, resolviendo la promesa...\");\r\n                            resolve(entries);\r\n                        }\r\n                    } catch (error) {\r\n                        //console.error(\"Error en el bloque try:\", error);\r\n                        reject(error);  // Rechazar la promesa en caso de error\r\n                    }\r\n                },\r\n                (error) => {\r\n                    //console.error(\"Error en la suscripción:\", error);\r\n                    reject(error);  // Manejar errores en la suscripción\r\n                }\r\n            );\r\n        }catch(error){\r\n            \r\n        }\r\n    });\r\n};\r\n\r\n\r\n\r\nself.objectToCsv = function(entries) {\r\n    let csvContent = '';\r\n    const keys = Object.keys(entries);\r\n\r\n    // Obtener las claves (columnas) para el encabezado CSV\r\n    csvContent += keys.join(';') + '\\n';\r\n\r\n    // Asumimos que todos los arrays en `entries` tienen la misma longitud\r\n    const maxLength = Math.max(...keys.map(key => entries[key].length));\r\n\r\n    // Iterar sobre los arrays de datos y agregar las filas al CSV\r\n    for (let i = 0; i < maxLength; i++) {\r\n        let row = keys.map(key => entries[key][i] ? entries[key][i].value : '').join(';');\r\n        csvContent += row + '\\n';\r\n    }\r\n\r\n    return csvContent;\r\n}\r\n\r\nself.getFormattedDate = function() {\r\n    const now = new Date();\r\n    const year = now.getFullYear();\r\n    const month = String(now.getMonth() + 1).padStart(2, '0');  // Los meses empiezan desde 0\r\n    const day = String(now.getDate()).padStart(2, '0');\r\n    const hours = String(now.getHours()).padStart(2, '0');\r\n    const minutes = String(now.getMinutes()).padStart(2, '0');\r\n    const seconds = String(now.getSeconds()).padStart(2, '0');\r\n\r\n    // Formato: YYYY-MM-DD_HH-MM-SS\r\n    return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;\r\n}\r\n\r\nself.downloadCsv = function(csvContent, fileNamePrefix) {\r\n    const formattedDate = self.getFormattedDate();  // Obtener la fecha y hora actual\r\n    const fileName = `${fileNamePrefix}_${formattedDate}.csv`;  // Nombre con prefijo y fecha\r\n\r\n    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\r\n    const link = document.createElement(\"a\");\r\n\r\n    if (link.download !== undefined) {\r\n        const url = URL.createObjectURL(blob);\r\n        link.setAttribute(\"href\", url);\r\n        link.setAttribute(\"download\", fileName);  // Nombre del archivo con la fecha\r\n        link.style.visibility = 'hidden';\r\n        document.body.appendChild(link);\r\n        link.click();\r\n        document.body.removeChild(link);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nself.loadTelemetryData = function() {\r\n    self.devices.forEach(function(device) {\r\n        let $injector = self.ctx.$scope.$injector;\r\n        let attributeService = $injector.get(self.ctx.servicesMap.get('attributeService'));\r\n        let entity = { entityType: 'DEVICE', id: device.entityId.id};\r\n        attributeService.getEntityTimeseriesLatest(\r\n                        entity).subscribe((\r\n                        labels) => {\r\n            var datakey = Object.keys(labels);\r\n            if(datakey.length > 0){\r\n                //debugger;\r\n    \r\n        \r\n                // Cargar telemetría completa (aumentar el límite si es necesario)\r\n                const startTs = 0;//Date.now() - (10 * 24 * 60 * 60 * 1000);\r\n                const endTs = Date.now();  // Ahora\r\n                attributeService.getEntityTimeseries(entity, datakey, startTs, endTs, 1000, false).subscribe(\r\n                    function(telemetryData) {\r\n                        debugger;\r\n                        if (telemetryData.ts && telemetryData[datakey[0]].length > 0) {\r\n                            let timestamps = telemetryData.telemetryData[datakey[0]].map(t => t.ts);  // Obtener las marcas de tiempo\r\n        \r\n                            // Obtener la primera y última telemetría\r\n                            let firstTimestamp = Math.min(...timestamps);\r\n                            let lastTimestamp = Math.max(...timestamps);\r\n        \r\n                            // Crear un objeto con los datos necesarios\r\n                            let entityData = {\r\n                                name: device.entityId.id,  // Reemplaza con el nombre si está disponible\r\n                                firstTelemetry: new Date(firstTimestamp).toLocaleString(),\r\n                                lastTelemetry: new Date(lastTimestamp).toLocaleString(),\r\n                                totalTelemetry: telemetryData.temperature.length\r\n                            };\r\n        \r\n                            self.entities.push(entityData);  // Añadir los datos a la lista\r\n                            self.ctx.detectChanges();  // Actualizar el widget\r\n                        } else {\r\n                            console.log(\"No se encontraron datos de telemetría para el dispositivo:\", device.entityId.id);\r\n                        }\r\n                    },\r\n                    function(error) {\r\n                        debugger;\r\n                        console.error('Error al cargar la telemetría:', error);\r\n                    }\r\n                );\r\n            }\r\n                \r\n        });\r\n        \r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n",
    "settingsSchema": "",
    "dataKeySettingsSchema": "",
    "settingsDirective": "",
    "defaultConfig": "{\"showTitle\":false,\"backgroundColor\":\"rgb(255, 255, 255)\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"TK_DeviceTable_v0.5\",\"dropShadow\":true,\"enableFullscreen\":false,\"widgetStyle\":{},\"widgetCss\":\"\",\"pageSize\":1024,\"noDataDisplayMessage\":\"\",\"showLegend\":false}"
  },
  "scada": false,
  "tags": [
    "limits"
  ]
}